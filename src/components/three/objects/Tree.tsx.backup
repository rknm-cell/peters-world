"use client";

import { useRef, useMemo, useEffect } from "react";
import { useFrame } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { COLOR_PALETTES } from "~/lib/constants";

// Preload all tree GLB files
const TREE_MODELS = [
  "tree", "tree-baobab", "tree-beech", "tree-birch", "tree-conifer",
  "tree-elipse", "tree-fir", "tree-forest", "tree-lime", "tree-maple",
  "tree-oak", "tree-round", "tree-spruce", "tree-tall"
] as const;

// Preload function
function preloadTreeModels() {
  TREE_MODELS.forEach(type => {
    useGLTF.preload(`/${type}.glb`);
  });
}

// Call preload
preloadTreeModels();

// Define the tree types based on available GLB files
type TreeType = 
  | "tree" 
  | "tree-baobab"
  | "tree-beech" 
  | "tree-birch"
  | "tree-conifer"
  | "tree-elipse"
  | "tree-fir"
  | "tree-forest"
  | "tree-lime"
  | "tree-maple"
  | "tree-oak"
  | "tree-round"
  | "tree-spruce"
  | "tree-tall";

interface TreeProps {
  type: TreeType;
  position: [number, number, number];
  rotation?: [number, number, number];
  scale?: [number, number, number];
  selected?: boolean;
  objectId: string;
  preview?: boolean;
  canPlace?: boolean;
}

export function Tree({
  type,
  position,
  rotation = [0, 0, 0],
  scale = [1, 1, 1],
  selected = false,
  objectId,
  preview = false,
  canPlace = true,
}: TreeProps) {
  const groupRef = useRef<THREE.Group>(null);

  // Always try to load the GLB file - React hooks must be called unconditionally
  const gltfResult = useGLTF(`/${type}.glb`);
  
  // Debug logging
  console.log(`Loading tree type: ${type}`, gltfResult);
  if (gltfResult && gltfResult.scene) {
    console.log(`Scene loaded successfully for ${type}:`, gltfResult.scene);
    console.log(`Scene children count:`, gltfResult.scene.children.length);
    
    // Log the entire scene hierarchy
    gltfResult.scene.traverse((child) => {
      console.log(`Scene child:`, {
        type: child.type,
        name: child.name,
        position: child.position.toArray(),
        scale: child.scale.toArray(),
        rotation: child.rotation.toArray(),
        matrix: child.matrix.elements,
        matrixWorld: child.matrixWorld.elements
      });
    });
  } else {
    console.log(`No scene loaded for tree type: ${type}`);
  }
  
  // Clone the scene to avoid sharing between instances
  const treeModel = useMemo(() => {
    if (!gltfResult || !gltfResult.scene) {
      return null;
    }

    const clonedScene = gltfResult.scene.clone(true);

    // Helper to adjust a single material safely
    const adjustMaterial = (mat: THREE.Material) => {
      if ((mat as any).color) {
        // Handle both MeshStandardMaterial and MeshPhysicalMaterial
        if (mat instanceof THREE.MeshStandardMaterial || mat instanceof THREE.MeshPhysicalMaterial) {
          const std = mat as THREE.MeshStandardMaterial;
          // Force visible values
          std.color.setHex(0x2ecc71);
          std.roughness = 0.7;
          std.metalness = 0.0;
          std.emissive.setHex(0x1f8f4e);
          std.emissiveIntensity = preview ? 0.5 : 0.3;
          std.transparent = false;
          std.opacity = 1.0;
          std.side = THREE.DoubleSide;
          std.fog = false;
        } else if (mat instanceof THREE.MeshBasicMaterial) {
          mat.color.set(0x2ecc71);
          mat.side = THREE.DoubleSide;
          mat.transparent = false;
          mat.opacity = 1.0;
        }
      }
    };

    // Apply materials that work well with directional lighting and shadows
    clonedScene.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // Disable culling in case bounding boxes are wrong
        child.frustumCulled = false;
        child.castShadow = true;
        child.receiveShadow = true;

        const originalMaterial = child.material;
        if (Array.isArray(originalMaterial)) {
          child.material = originalMaterial.map((m) => {
            const cloned = m.clone();
            adjustMaterial(cloned);
            return cloned;
          });
        } else if (originalMaterial) {
          const cloned = originalMaterial.clone();
          adjustMaterial(cloned);
          child.material = cloned;
        }
      }
    });

    // CRITICAL: Handle Blender export issues by properly centering geometry
    // First, reset all transformations to identity
    clonedScene.position.set(0, 0, 0);
    clonedScene.rotation.set(0, 0, 0);
    clonedScene.scale.set(1, 1, 1);
    
    // Clear any internal matrix transformations
    clonedScene.matrix.identity();
    clonedScene.matrixWorld.identity();
    clonedScene.matrixAutoUpdate = false;
    clonedScene.matrixWorldAutoUpdate = false;
    
    // Now traverse and center each mesh's geometry properly
    clonedScene.traverse((child) => {
      if (child instanceof THREE.Mesh) {
        // Reset mesh transformations
        child.position.set(0, 0, 0);
        child.rotation.set(0, 0, 0);
        child.scale.set(1, 1, 1);
        child.matrix.identity();
        child.matrixWorld.identity();
        child.matrixAutoUpdate = false;
        child.matrixWorldAutoUpdate = false;
        
        // Center the geometry itself by modifying vertices
        if (child.geometry) {
          const geometry = child.geometry;
          if (geometry.attributes.position) {
            const positions = geometry.attributes.position.array;
            const count = positions.length / 3;
            
            // Calculate center of this mesh's geometry
            let meshCenterX = 0, meshCenterY = 0, meshCenterZ = 0;
            for (let i = 0; i < count; i++) {
              meshCenterX += positions[i * 3];
              meshCenterY += positions[i * 3 + 1];
              meshCenterZ += positions[i * 3 + 2];
            }
            meshCenterX /= count;
            meshCenterY /= count;
            meshCenterZ /= count;
            
            // Center the geometry by moving vertices
            for (let i = 0; i < count; i++) {
              positions[i * 3] -= meshCenterX;
              positions[i * 3 + 1] -= meshCenterY;
              positions[i * 3 + 2] -= meshCenterZ;
            }
            
            // Mark geometry as needing update
            geometry.attributes.position.needsUpdate = true;
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
          }
        }
      }
    });
    
    // Re-enable matrix updates
    clonedScene.matrixAutoUpdate = true;
    clonedScene.matrixWorldAutoUpdate = true;
    
    // Now recalculate bounding box after geometry centering
    const centeredBox = new THREE.Box3().setFromObject(clonedScene);
    const centeredSize = new THREE.Vector3();
    const centeredCenter = new THREE.Vector3();
    centeredBox.getSize(centeredSize);
    centeredBox.getCenter(centeredCenter);
    
    console.log(`After geometry centering:`, {
      size: centeredSize.toArray(),
      center: centeredCenter.toArray(),
      'should be near [0,0,0]': centeredCenter.toArray()
    });
    
    // Scale to target height - make trees much smaller to fit on globe
    const targetHeight = 0.3; // Reduced to 5% of globe radius for realistic proportions
    const currentHeight = Math.max(centeredSize.y, 0.001);
    const scaleFactor = targetHeight / currentHeight;
    clonedScene.scale.setScalar(scaleFactor);
    
    // The tree is now centered and scaled. The placement system will position it correctly.
    console.log(`Tree ready for placement:`, {
      targetHeight,
      scaleFactor,
      'tree is centered and scaled'
    });

    return clonedScene;
  }, [gltfResult?.scene, preview, type]);

  // Animation for selected state
  useFrame((state) => {
    if (groupRef.current && selected) {
      groupRef.current.rotation.y = Math.sin(state.clock.elapsedTime * 2) * 0.1;
    } else if (groupRef.current) {
      groupRef.current.rotation.y = rotation[1];
    }
  });

  if (!treeModel) {
    console.log(`No tree model for type: ${type}, showing fallback`);
    // Fallback to a simple visible tree for debugging
    return (
      <group
        ref={groupRef}
        position={position}
        rotation={rotation}
        scale={scale}
        userData={{ isPlacedObject: true, objectId }}
      >
        {/* Debug sphere to make tree position visible */}
        <mesh position={[0, 0, 0]}>
          <sphereGeometry args={[0.2, 8, 6]} />
          <meshBasicMaterial color="#ff0000" />
        </mesh>
        
        {/* Fallback simple tree */}
        <mesh position={[0, 0.5, 0]} castShadow receiveShadow>
          <cylinderGeometry args={[0.2, 0.3, 2, 8]} />
          <meshStandardMaterial color="#8B4513" />
        </mesh>
        <mesh position={[0, 2.5, 0]} castShadow receiveShadow>
          <coneGeometry args={[1.6, 4, 8]} />
          <meshStandardMaterial color="#228B22" />
        </mesh>
        
        {/* Selection indicator */}
        {selected && (
          <mesh position={[0, -0.1, 0]}>
            <ringGeometry args={[0.8, 1.0, 16]} />
            <meshBasicMaterial color="#ffff00" transparent opacity={0.6} />
          </mesh>
        )}
      </group>
    );
  }

  console.log(`Rendering GLB tree type: ${type} at position:`, position);

  return (
    <group
      ref={groupRef}
      position={position}
      rotation={rotation}
      scale={scale}
      userData={{ isPlacedObject: true, objectId }}
    >
      {/* Debug info */}
      <mesh position={[0, 0, 0]}>
        <sphereGeometry args={[0.1, 8, 6]} />
        <meshBasicMaterial color="#ff0000" />
      </mesh>
      
      {/* Base indicator - shows where the tree should be grounded */}
      <mesh position={[0, -0.05, 0]}>
        <cylinderGeometry args={[0.2, 0.2, 0.1, 8]} />
        <meshBasicMaterial color="#00ff00" transparent opacity={0.7} />
      </mesh>
      
      {/* Render the GLB model */}
      <primitive object={treeModel} />

      {/* Debug bounding box */}
      <mesh position={[0, 0, 0]}>
        <boxGeometry args={[2, 4, 2]} />
        <meshBasicMaterial color="#00ff00" wireframe={true} transparent opacity={0.3} />
      </mesh>

      {/* Selection indicator */}
      {selected && (
        <mesh position={[0, -0.1, 0]}>
          <ringGeometry args={[0.8, 1.0, 16]} />
          <meshBasicMaterial color="#ffff00" transparent opacity={0.6} />
        </mesh>
      )}
    </group>
  );
}
